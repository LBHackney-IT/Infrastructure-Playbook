(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{111:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return c}));var o=n(3),r=n(7),a=(n(0),n(137)),i={id:"tdd",title:"Good TDD Principles"},s={unversionedId:"tdd",id:"tdd",isDocsHomePage:!1,title:"Good TDD Principles",description:"Purpose",source:"@site/docs/tdd.md",slug:"/tdd",permalink:"/Infrastructure-Playbook/tdd",editUrl:"https://github.com/LBHackney-IT/Infrastructure-Playbook/edit/master/docs/tdd.md",version:"current"},l=[{value:"Purpose",id:"purpose",children:[]},{value:"Introduction",id:"introduction",children:[]},{value:"TDD Principles",id:"tdd-principles",children:[{value:"Test Setup",id:"test-setup",children:[]},{value:"Test Naming",id:"test-naming",children:[]},{value:"Unit Tests",id:"unit-tests",children:[]},{value:"Red-Green-Refactor-Commit",id:"red-green-refactor-commit",children:[]}]},{value:"End-to-end Tests",id:"end-to-end-tests",children:[]},{value:"Test Coverage",id:"test-coverage",children:[]},{value:"When should you fake it?",id:"when-should-you-fake-it",children:[]}],u={toc:l};function c(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"purpose"},"Purpose"),Object(a.b)("p",null,"The purpose of this section is to provide some general guidelines on how we conduct testing in our applications.  This will give our developers some baseline standards on how to go about testing.  These guidelines are not intended to be prescriptive on what developers should test but to ensure that with a consistent understanding of our tests, it will be easy to grasp by other developers."),Object(a.b)("h2",{id:"introduction"},"Introduction"),Object(a.b)("p",null,"Hackney\u2019s development standards have evolved over the past couple of years and one of the underpinning principles of this evolution is the adoption of ",Object(a.b)("strong",{parentName:"p"},"Test-Driven Development")," (TDD) where developers are encouraged to start implementing a solution by first writing tests. These tests should describe the feature being implemented and should steer the implementation as it develops. The tests should let developers know what a unit or module is expected to do and should provide feedback on whether or not what was required has been achieved.  It is also useful to have these tests in place as a means of regression testing. As your implementation grows it becomes more and more difficult to determine if any previous code gets broken by newer functionality. With proper test coverage, regression testing is included by default."),Object(a.b)("h2",{id:"tdd-principles"},"TDD Principles"),Object(a.b)("p",null,"The following are some of the principles we have adopted as part of our TDD principles.  These are meant to be used as guidelines for testing your application:"),Object(a.b)("h3",{id:"test-setup"},"Test Setup"),Object(a.b)("p",null,"Always follow the triple \u2018A\u2019 structure: Arrange, Act, Assert"),Object(a.b)("h3",{id:"test-naming"},"Test Naming"),Object(a.b)("p",null,"Tests should be clearly named - ideally the name of the test should describe the implementation you are trying to deliver.  "),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-dotnet"},"public void Test1()\n")),Object(a.b)("p",null,Object(a.b)("em",{parentName:"p"},"Not a good test name")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-dotnet"},"public void GetResidentWithValidIdReturnsCorrectRecord()\n")),Object(a.b)("p",null,Object(a.b)("em",{parentName:"p"},"A better test name that describes what is being tested")),Object(a.b)("h3",{id:"unit-tests"},"Unit Tests"),Object(a.b)("p",null,"Unit tests should provide good coverage of the various scenarios that may be encountered; from the main success scenario to any exceptionals or edge cases.\n",Object(a.b)("a",{parentName:"p",href:"/unit_testing"},"See More")),Object(a.b)("h3",{id:"red-green-refactor-commit"},"Red-Green-Refactor-Commit"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Red"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"Write the unit test as the basic function you want the code to fulfil which will fail"),Object(a.b)("li",{parentName:"ul"},"Write only as much code as is required to resolve the current error"),Object(a.b)("li",{parentName:"ul"},"EG: Our first test states that a specific method will return a specific value. At the start of development, this method will not exist, so the test will fail, as the error states that the method does not exist, create that method, but have it return null"))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Green"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"Write the minimum code required to get a test to pass"),Object(a.b)("li",{parentName:"ul"},"EG: If our test states that our method will return a specific value, we write the code to provide that value only. We could then write more complex tests to develop greater complexity"))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Refactor"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"When the tests pass, refactor to simplify the code"),Object(a.b)("li",{parentName:"ul"},"When using the same variable value multiple times, extract it to SetUp"))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Commit"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"Save it to GitHub")))),Object(a.b)("h2",{id:"end-to-end-tests"},"End-to-end Tests"),Object(a.b)("p",null,"There should be end-to-end tests to test each feature you are implementing. You can have good coverage of unit tests any they may all pass, but they can easily overlook issues with how each unit interacts with others. End-to-end tests can pick up on these types of issues.\nEnd-to-end tests can test and validate that a feature is implemented as per user need.\nEnd-to-end tests are also good for regression testing; ensuring that each new implementation doesn\u2019t break the behaviour of the feature as a whole."),Object(a.b)("h2",{id:"test-coverage"},"Test Coverage"),Object(a.b)("p",null,"Test coverage is all about ensuring that your implementation is sufficiently tested.  It is a method of quality checking the tests in our code, ensuring that it covers all possible scenarios and outcomes that your piece of code is expected to capture.\nTest coverage is used as a metric to specify how much of our code needs to be covered by tests.  This will also encourage sufficient refactoring of code so that larger implementations can be broken down into smaller testable chunks.\n","[We need to determine what our test coverage standards should be]"),Object(a.b)("h2",{id:"when-should-you-fake-it"},"When should you fake it?"),Object(a.b)("p",null,"We use a number of different tools to \u2018fake\u2019 or simulate the output of dependent modules not directly tested.  Modules such as Fakr, Moq, Bogus, etc are used across our development.  There is no specific requirement for any one of these to be used.  However, when used, they should be used in an appropriate manner.  The following are some guidelines on when you should fake an implementation."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"When to fake it:")),Object(a.b)("p",null,"When a unit being tested has a dependency on another unit whose output is not directly part of a test, the dependency\u2019s output can be faked.  For example if you are testing a unit that call another unit for data and you are not directly testing the data that gets returned, only what the unit does with the data.  The unit that returns the data can be faked."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"When not to fake it:")),Object(a.b)("p",null,"If you are testing a piece of code\u2019s output you will not fake the output you expect from the unit as you will not be able to get a useful test outcome.  For example, if your unit accepts two numbers (2 and 2) and you are testing that it returns 4.  You will create a fake output of \u20184\u2019 in your implementation and test that your unit returns \u20184\u2019"))}c.isMDXComponent=!0},137:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return h}));var o=n(0),r=n.n(o);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=r.a.createContext({}),c=function(e){var t=r.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=c(e.components);return r.a.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),b=o,h=d["".concat(i,".").concat(b)]||d[b]||p[b]||a;return n?r.a.createElement(h,s(s({ref:t},u),{},{components:n})):r.a.createElement(h,s({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=b;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var u=2;u<a;u++)i[u]=n[u];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);