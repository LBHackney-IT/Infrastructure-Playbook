(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{125:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return p}));var i=n(3),a=n(7),r=(n(0),n(137)),o={id:"compatibility",title:"Compatibility"},s={unversionedId:"compatibility",id:"compatibility",isDocsHomePage:!1,title:"Compatibility",description:"MUST Maintain Backward Compatibility",source:"@site/docs/compatibility.md",slug:"/compatibility",permalink:"/Infrastructure-Playbook/compatibility",editUrl:"https://github.com/LBHackney-IT/Infrastructure-Playbook/edit/master/docs/compatibility.md",version:"current"},l=[{value:"MUST Maintain Backward Compatibility",id:"must-maintain-backward-compatibility",children:[]},{value:"SHOULD Prefer Compatible Changes",id:"should-prefer-compatible-changes",children:[]},{value:"MUST Prepare Clients To Not Crash On Compatible API Extensions",id:"must-prepare-clients-to-not-crash-on-compatible-api-extensions",children:[]},{value:"SHOULD Design APIs Conservatively",id:"should-design-apis-conservatively",children:[]},{value:"SHOULD Avoid Versioning",id:"should-avoid-versioning",children:[]},{value:"MUST Use URI Versioning",id:"must-use-uri-versioning",children:[]}],c={toc:l};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"must-maintain-backward-compatibility"},"MUST Maintain Backward Compatibility"),Object(r.b)("p",null,"Change APIs, but keep all consumers running. Consumers usually have independent release lifecycles, focus on stability, and avoid changes that do not provide additional value. APIs are contracts between service providers and service consumers that cannot be broken via unilateral decisions."),Object(r.b)("p",null,"There are two techniques to change APIs without breaking them:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"follow rules for compatible extensions")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"introduce new API versions and still support older versions"))),Object(r.b)("p",null,"We strongly encourage using compatible API changes and discourage versioning. The following guidelines for service providers and consumers enable us to make compatible changes without versioning."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Note:")," There is a difference between incompatible and breaking changes. Incompatible changes are changes that are not covered by the compatibility rules below. Breaking changes are incompatible changes deployed into operation, and thereby breaking running API consumers. Usually, incompatible changes are breaking changes when deployed into operation. However, in specific controlled situations it is possible to deploy incompatible changes in a non-breaking way, if no API consumer is using the affected API aspects (see also ",Object(r.b)("a",{parentName:"p",href:"/Infrastructure-Playbook/deprecation"},"Deprecation"),")."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Hint:"),' Please note that the compatibility guarantees are for the "on the wire" format. Binary or source compatibility of code generated from an API definition is not covered by these rules. If client implementations update their generation process to a new version of the API definition, it has to be expected that code changes are necessary.'),Object(r.b)("h2",{id:"should-prefer-compatible-changes"},"SHOULD Prefer Compatible Changes"),Object(r.b)("p",null,"API designers should apply the following rules to evolve RESTful APIs for services in a backward-compatible way:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Add only optional, never mandatory fields.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Never change the semantics of fields (e.g. changing the semantics from customer-number to customer-id, as both are     different unique customer keys)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Input fields may have (complex) constraints being validated via server-side business logic. Never change the validation logic to be more restrictive and make sure that all constraints are clearly defined in description.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Support redirection in case an URL has to change (",Object(r.b)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/HTTP_301"},"301 Moved Permanently"),")."))),Object(r.b)("h2",{id:"must-prepare-clients-to-not-crash-on-compatible-api-extensions"},"MUST Prepare Clients To Not Crash On Compatible API Extensions"),Object(r.b)("p",null,"Service clients should apply the robustness principle:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Be conservative with API requests and data passed as input, e.g. avoid to exploit definition deficits like passing megabytes for strings with unspecified maximum length.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Be tolerant in processing and reading data of API responses"))),Object(r.b)("p",null,"Service clients must be prepared for compatible API extensions of service providers:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Be tolerant with unknown fields in the payload (see also Fowler\u2019s ",Object(r.b)("a",{parentName:"p",href:"http://martinfowler.com/bliki/TolerantReader.html"},'"TolerantReader"')," post), i.e. ignore new fields but do not eliminate them from payload if needed for subsequent PUT requests.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Be prepared to handle HTTP status codes not explicitly specified in endpoint definitions. Note also, that status codes are extensible. Default handling is how you would treat the corresponding x00 code (see ",Object(r.b)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7231#section-6"},"RFC7231 Section 6"),").")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Follow the redirect when the server returns HTTP status ",Object(r.b)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/HTTP_301"},"301 Moved Permanently"),"."))),Object(r.b)("h2",{id:"should-design-apis-conservatively"},"SHOULD Design APIs Conservatively"),Object(r.b)("p",null,"Designers of service provider APIs should be conservative and accurate in what they accept from clients:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Unknown input fields in payload or URL should not be ignored; servers should provide error feedback to clients via an HTTP 400 response code.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Be accurate in defining input data constraints (like formats, ranges, lengths etc.) \u2014 and check constraints and return dedicated error information in case of violations.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Prefer being more specific and restrictive (if compliant to functional requirements), e.g. by defining length range of strings. It may simplify implementation while providing freedom for further evolution as compatible extensions."))),Object(r.b)("p",null,"Not ignoring unknown input fields is a specific deviation from Postel\u2019s Law (e.g. see also",Object(r.b)("br",{parentName:"p"}),"\n",Object(r.b)("a",{parentName:"p",href:"https://cacm.acm.org/magazines/2011/8/114933-the-robustness-principle-reconsidered/fulltext"},"The Robustness Principle Reconsidered"),") and a strong recommendation. Servers might want to take a different approach but should be aware of the following problems and be explicit in what is supported:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'Ignoring unknown input fields is actually not an option for PUT, since it becomes asymmetric with subsequent GET response and HTTP is clear about the PUT "replace" semantics and default roundtrip expectations (see ',Object(r.b)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7231#section-4.3.4"},"RFC7231 Section 4.3.4"),"). Note, accepting (i.e. not ignoring) unknown input fields and returning it in subsequent GET responses is a different situation and compliant to PUT semantics.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Certain client errors cannot be recognized by servers, e.g. attribute name typing errors will be ignored without server error feedback. The server cannot differentiate between the client intentionally providing an additional field versus the client sending a mistakenly named field, when the client\u2019s actual intent was to provide an optional input field.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Future extensions of the input data structure might be in conflict with already ignored fields and, hence, will not be compatible, i.e. break clients that already use this field but with different type."))),Object(r.b)("p",null,'In specific situations, where a (known) input field is not needed anymore, it either can stay in the API definition with "not used anymore" description or can be removed from the API definition as long as the server ignores this specific parameter.'),Object(r.b)("h2",{id:"should-avoid-versioning"},"SHOULD Avoid Versioning"),Object(r.b)("p",null,"When changing your RESTful APIs, do so in a compatible way and avoid generating additional API versions. Multiple versions can significantly complicate understanding, testing, maintaining, evolving, operating and releasing our systems ",Object(r.b)("a",{parentName:"p",href:"http://martinfowler.com/articles/enterpriseREST.html"},"supplementary reading"),")."),Object(r.b)("p",null,"If changing an API can\u2019t be done in a compatible way, then proceed in one of these three ways:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"create a new resource (variant) in addition to the old resource variant")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"create a new service endpoint \u2014 i.e. a new application with a new API (with a new domain name)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"create a new API version supported in parallel with the old API by the same microservice"))),Object(r.b)("p",null,"As we discourage versioning by all means because of the manifold disadvantages, we strongly recommend to only use the first two approaches. Versioning should be a last resort."),Object(r.b)("h2",{id:"must-use-uri-versioning"},"MUST Use URI Versioning"),Object(r.b)("p",null,"With URI versioning a (major) version number is included in the path, e.g. /v1/customers. If you don't put it in at the beginning then it's almost impossible to retro-fit"))}p.isMDXComponent=!0},137:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var i=n(0),a=n.n(i);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),p=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=p(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=p(n),d=i,m=b["".concat(o,".").concat(d)]||b[d]||u[d]||r;return n?a.a.createElement(m,s(s({ref:t},c),{},{components:n})):a.a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);